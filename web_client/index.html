<!DOCTYPE HTML>
<html>
    <head>
        <title>boxatar web client</title>
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>

    <body>
        <canvas id="canvas" width="1512" height="130" style="display: block;"></canvas><br>
        <button id="start_audio">start audio</button><button id="stop_audio">stop audio</button><br>
        avg = <span id="avg">avg</span><br>
        max = <span id="max">max</span><br>
        min = <span id="min">min</span><br>
        peaks = <span id="peaks">peaks</span><br>
        <button id="start_speech">start speech</button><button id="stop_speech">stop speech</button><br>
        text = <span id="text">text</span><br>
        <button id="connect">connect to python server</button><br>
        <script src="socketmanager.js"></script>
        <script>
            // set up speech recognition
            var recognition = new webkitSpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = "en";

            recognition.onresult = function (event) {
                for (var i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        document.getElementById("text").innerText += " " + event.results[i][0].transcript;
                    }
                }
            };

            document.getElementById("start_speech").onclick = function() {
                recognition.start();
            };

            document.getElementById("stop_speech").onclick = function() {
                recognition.stop();
            };

            // error callback for getUserMedia function
            var errorlog = function(e) {
                console.log("Rejected.", e);
            };

            window.AudioContext = window.AudioContext ||
                                  window.webkitAudioContext;

            var context = new AudioContext();

            navigator.getUserMedia = navigator.getUserMedia ||
                                     navigator.webkitGetUserMedia ||
                                     navigator.mozGetUserMedia ||
                                     navigator.msGetUserMedia;

            // set up input node, analyser node, frequency array, AND STARTS INTERVAL TIMER
            var input, filter, analyser, audio_interval, analysis_interval, freqdomain;
            navigator.getUserMedia({audio: true}, function(stream) {
                input = context.createMediaStreamSource(stream);
                filter = context.createBiquadFilter();
                analyser = context.createAnalyser();
                analyser.smoothingTimeConstant = 0.3;
                analyser.fftSize = 1024;
                input.connect(filter);
                filter.connect(analyser);

                freqdomain = new Float32Array(analyser.frequencyBinCount);
            }, errorlog);

            document.getElementById("start_audio").onclick = function() {
                audio_interval = setInterval(update, 10);
                analysis_interval = setInterval(analysetimedomain, 500);
            };

            document.getElementById("stop_audio").onclick = function() {
                clearInterval(audio_interval);
                clearInterval(analysis_interval);
            };

            // using fft output, calculate 'volume' of audio
            var getvolume = function(freqs) {
                var sum = 0;

                for (i = 0; i < freqs.length; i++) {
                    sum += freqs[i];
                }

                return sum / freqs.length;
            };

            // populate array with 0's
            var timespectrum = Array.apply(null, new Array(200)).map(Number.prototype.valueOf, -160);
            // shift oldest volume out of array, push new volume to end of array
            var doarraystuff = function() {
                analyser.getFloatFrequencyData(freqdomain);
                var volume = getvolume(freqdomain);

                timespectrum.shift();
                timespectrum.push(volume);
            };

            // calculates important stats from volume array
            var max, min, avg, peaks;
            var analysetimedomain = function() {
                var sum = 0;
                min = Number.MAX_VALUE;
                max = -Number.MAX_VALUE;
                peaks = 0;

                for (i = 0; i < timespectrum.length; i++) {
                    sum += timespectrum[i];

                    if (timespectrum[i] < min) {
                        min = timespectrum[i];
                    }

                    if (timespectrum[i] > max) {
                        max = timespectrum[i];
                    }
                }

                avg = sum / timespectrum.length;

                for (i = 0; i < timespectrum.length; i++) {
                    if (timespectrum[i] > (max - min) * 0.9 + min) {
                        peaks++;
                    }
                }

                document.getElementById("avg").innerText = avg;
                document.getElementById("max").innerText = max;
                document.getElementById("min").innerText = min;
                document.getElementById("peaks").innerText = peaks;
            };

            // linear interpolation
            var lerp = function(input, inrange0, inrange1, outrange0, outrange1) {
                return outrange0 + (outrange1 - outrange0) * ((input - inrange0) / (inrange1 - inrange0));
            };

            // canvas drawing happens here
            var canvas = document.getElementById("canvas").getContext("2d");
            var update = function() {
                doarraystuff();

                canvas.clearRect(0, 0, 1512, 130);
                canvas.fillStyle = "#000000";

                for (i = 0; i < 200; i++) {
                    var rect = lerp(timespectrum[i], min, max, 0, -130);
                    canvas.fillRect(i * 5, 130, 4, rect);
                }

                for (i = 0; i < 512; i++) {
                    var rect = -freqdomain[i] - 70;
                    canvas.fillRect(1000 + i, rect, 1, 1);
                }
            };
//            // set up webrtc stuff
//            var channel = location.href.replace( /\/|:|#|%|\.|\[|\]/g , '');
//            var websocket = new WebSocket('ws://localhost:8080');
//            websocket.onopen = function() {
//                websocket.push(JSON.stringify({
//                    open: true,
//                    channel: channel
//                }));
//            };
//            websocket.push = websocket.send;
//            websocket.send = function(data) {
//                websocket.push(JSON.stringify({
//                    data: data,
//                    channel: channel
//                }));
//            };
//
//            var peer = new PeerConnection(websocket);
//            peer.onUserFound = function(userid) {
//                if (document.getElementById(userid)) return;
//                var tr = document.createElement('tr');
//                var td1 = document.createElement('td');
//                var td2 = document.createElement('td');
//
//                td1.innerHTML = userid + ' is present. connect?';
//
//                var button = document.createElement('button');
//                button.innerHTML = 'Join';
//                button.id = userid;
//                button.onclick = function() {
//                    button = this;
//                    getUserMedia(function(stream) {
//                        peer.addStream(stream);
//                        peer.sendParticipationRequest(button.id);
//                    });
//                    button.disabled = true;
//                };
//                td2.appendChild(button);
//
//                tr.appendChild(td1);
//                tr.appendChild(td2);
//                roomsList.appendChild(tr);
//            };
//
//            peer.onStreamAdded = function(e) {
//                console.log("STREAM ADDED");
//            };
//
//            peer.onStreamEnded = function(e) {
//                console.log("STREAM ENDED");
//            };
//
//            document.getElementById("start-broadcasting").onclick = function() {
//                this.disabled = true;
//                getUserMedia(function(stream) {
//                    peer.addStream(stream);
//                    peer.startBroadcasting();
//                });
//            };
//
//            function getUserMedia(callback) {
//                var hints = { audio: true };
//                navigator.getUserMedia(hints, function(stream) {
//                    console.log("DOING SOMETHING, FIND THIS PRINT STATEMENT");
//                    peer.onStreamAdded({
//
//                    });
//
//                    callback(stream);
//                });
//            }
        </script>
    </body>
</html>
